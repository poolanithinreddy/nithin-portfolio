[
  {
    "title": "Mapping SAML roles to app RBAC without breaking sessions",
    "summary": "Practical lessons from aligning Shibboleth SAML assertions with fine-grained RBAC scopes in CyberRange.",
    "publishedAt": "2024-06-12T00:00:00.000Z",
    "tags": [
      "SAML",
      "Security",
      "RBAC"
    ],
    "body": {
      "raw": "\nKeeping campus identity providers in sync with application roles can go sideways quickly—especially when you introduce per-action audit requirements. This post outlines the guardrails we applied while wiring UMBC’s Shibboleth IdP to the CyberRange portal.\n\n## Start with a role contract\n\nBefore writing code, agree on a contract with the identity team. We specified:\n\n- Canonical attribute names (`urn:oid:1.3.6.1.4.1.5923.1.5.1.1` for eduPersonAffiliation)\n- Allowed values per attribute and what scopes they unlock\n- Expected NameID format (transient vs. persistent)\n\n## Map to scopes, not UI roles\n\nWe maintained a `scopes.json` that translated IdP roles to backend capabilities. The UI simply asked the API: “Does this user have `labs:power:cycle`?” That separation prevented awkward UI drift when the identity team renamed groups.\n\n## Harden the session lifecycle\n\n- Cookies set to `SameSite=strict`, `HttpOnly`, and `Secure`\n- AES-encrypted session payload with rotating keys stored in HashiCorp Vault\n- CSRF double-submit tokens on all mutation routes\n\n## Audit everything\n\nWe streamed sensitive events (console open, template clone, role change) to Mongo change streams and persisted them in Postgres for reporting. Every audit record links to the original SAML assertion, making compliance reviews painless.\n\n## Wrap-up\n\nThe end result: faculty now approve lab access with confidence that session state and RBAC scopes move in lockstep with campus identity.\n",
      "code": "var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},o=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!g.call(t,r)&&r!==i&&s(t,r,{get:()=>e[r],enumerable:!(a=p(e,r))||a.enumerable});return t};var f=(t,e,i)=>(i=t!=null?h(m(t)):{},o(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),b=t=>o(s({},\"__esModule\",{value:!0}),t);var l=y((M,c)=>{c.exports=_jsx_runtime});var S={};w(S,{default:()=>C,frontmatter:()=>v});var n=f(l()),v={title:\"Mapping SAML roles to app RBAC without breaking sessions\",summary:\"Practical lessons from aligning Shibboleth SAML assertions with fine-grained RBAC scopes in CyberRange.\",publishedAt:\"2024-06-12\",tags:[\"SAML\",\"Security\",\"RBAC\"]};function d(t){let e=Object.assign({p:\"p\",h2:\"h2\",a:\"a\",ul:\"ul\",li:\"li\",code:\"code\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Keeping campus identity providers in sync with application roles can go sideways quickly\\u2014especially when you introduce per-action audit requirements. This post outlines the guardrails we applied while wiring UMBC\\u2019s Shibboleth IdP to the CyberRange portal.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"start-with-a-role-contract\",children:(0,n.jsx)(e.a,{href:\"#start-with-a-role-contract\",children:\"Start with a role contract\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Before writing code, agree on a contract with the identity team. We specified:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Canonical attribute names (\",(0,n.jsx)(e.code,{children:\"urn:oid:1.3.6.1.4.1.5923.1.5.1.1\"}),\" for eduPersonAffiliation)\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Allowed values per attribute and what scopes they unlock\"}),`\n`,(0,n.jsx)(e.li,{children:\"Expected NameID format (transient vs. persistent)\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{id:\"map-to-scopes-not-ui-roles\",children:(0,n.jsx)(e.a,{href:\"#map-to-scopes-not-ui-roles\",children:\"Map to scopes, not UI roles\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We maintained a \",(0,n.jsx)(e.code,{children:\"scopes.json\"}),\" that translated IdP roles to backend capabilities. The UI simply asked the API: \\u201CDoes this user have \",(0,n.jsx)(e.code,{children:\"labs:power:cycle\"}),\"?\\u201D That separation prevented awkward UI drift when the identity team renamed groups.\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"harden-the-session-lifecycle\",children:(0,n.jsx)(e.a,{href:\"#harden-the-session-lifecycle\",children:\"Harden the session lifecycle\"})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Cookies set to \",(0,n.jsx)(e.code,{children:\"SameSite=strict\"}),\", \",(0,n.jsx)(e.code,{children:\"HttpOnly\"}),\", and \",(0,n.jsx)(e.code,{children:\"Secure\"})]}),`\n`,(0,n.jsx)(e.li,{children:\"AES-encrypted session payload with rotating keys stored in HashiCorp Vault\"}),`\n`,(0,n.jsx)(e.li,{children:\"CSRF double-submit tokens on all mutation routes\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{id:\"audit-everything\",children:(0,n.jsx)(e.a,{href:\"#audit-everything\",children:\"Audit everything\"})}),`\n`,(0,n.jsx)(e.p,{children:\"We streamed sensitive events (console open, template clone, role change) to Mongo change streams and persisted them in Postgres for reporting. Every audit record links to the original SAML assertion, making compliance reviews painless.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"wrap-up\",children:(0,n.jsx)(e.a,{href:\"#wrap-up\",children:\"Wrap-up\"})}),`\n`,(0,n.jsx)(e.p,{children:\"The end result: faculty now approve lab access with confidence that session state and RBAC scopes move in lockstep with campus identity.\"})]})}function A(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var C=A;return b(S);})();\n;return Component;"
    },
    "_id": "blog/saml-rbac.mdx",
    "_raw": {
      "sourceFilePath": "blog/saml-rbac.mdx",
      "sourceFileName": "saml-rbac.mdx",
      "sourceFileDir": "blog",
      "contentType": "mdx",
      "flattenedPath": "blog/saml-rbac"
    },
    "type": "Post",
    "slug": "saml-rbac",
    "url": "/blog/saml-rbac"
  },
  {
    "title": "vCenter golden templates playbook",
    "summary": "How we standardized VMware lab images with post-provision scripts, compliance checks, and automated health reporting.",
    "publishedAt": "2024-04-28T00:00:00.000Z",
    "tags": [
      "VMware",
      "Automation",
      "DevOps"
    ],
    "body": {
      "raw": "\nFaculty needed consistent lab environments that could reset every week without manual babysitting. Golden templates gave us the consistency we wanted, but the playbook required a few careful steps.\n\n## Step 1: Build immutable baselines\n\nStart with a clean OS install, capture checksums, and run CIS hardening scripts. Every template gets a metadata file explaining who built it, what scripts ran, and which courses consume it.\n\n## Step 2: Post-provision customization\n\nA provisioning worker triggers PowerCLI + Ansible scripts immediately after cloning:\n\n- Inject course-specific SSH keys and jump-host routes\n- Register agents for logging/metrics\n- Run smoke tests (DNS, outbound, identity) before marking the VM as ready\n\n## Step 3: Continuous validation\n\nA nightly job rehydrates sample VMs from each template, runs compliance scans, and feeds the results into Grafana dashboards. If drift appears, we can flag the template, notify owners, and block new labs until it’s healthy.\n\n## Step 4: Retirement workflow\n\nWhen a template ages out, we snapshot it, store the artifacts in object storage, and document the replacement in the knowledge base. Faculty see the impact in the portal release notes, keeping everyone aligned.\n\nTemplates went from “mystery meat” to a predictable, observable backbone for CyberRange labs.\n",
      "code": "var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=>{for(var i in e)s(n,i,{get:e[i],enumerable:!0})},o=(n,e,i,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of u(e))!b.call(n,a)&&a!==i&&s(n,a,{get:()=>e[a],enumerable:!(r=p(e,a))||r.enumerable});return n};var w=(n,e,i)=>(i=n!=null?h(m(n)):{},o(e||!n||!n.__esModule?s(i,\"default\",{value:n,enumerable:!0}):i,n)),y=n=>o(s({},\"__esModule\",{value:!0}),n);var c=g((C,l)=>{l.exports=_jsx_runtime});var x={};f(x,{default:()=>j,frontmatter:()=>k});var t=w(c()),k={title:\"vCenter golden templates playbook\",summary:\"How we standardized VMware lab images with post-provision scripts, compliance checks, and automated health reporting.\",publishedAt:\"2024-04-28\",tags:[\"VMware\",\"Automation\",\"DevOps\"]};function d(n){let e=Object.assign({p:\"p\",h2:\"h2\",a:\"a\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"Faculty needed consistent lab environments that could reset every week without manual babysitting. Golden templates gave us the consistency we wanted, but the playbook required a few careful steps.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"step-1-build-immutable-baselines\",children:(0,t.jsx)(e.a,{href:\"#step-1-build-immutable-baselines\",children:\"Step 1: Build immutable baselines\"})}),`\n`,(0,t.jsx)(e.p,{children:\"Start with a clean OS install, capture checksums, and run CIS hardening scripts. Every template gets a metadata file explaining who built it, what scripts ran, and which courses consume it.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"step-2-post-provision-customization\",children:(0,t.jsx)(e.a,{href:\"#step-2-post-provision-customization\",children:\"Step 2: Post-provision customization\"})}),`\n`,(0,t.jsx)(e.p,{children:\"A provisioning worker triggers PowerCLI + Ansible scripts immediately after cloning:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Inject course-specific SSH keys and jump-host routes\"}),`\n`,(0,t.jsx)(e.li,{children:\"Register agents for logging/metrics\"}),`\n`,(0,t.jsx)(e.li,{children:\"Run smoke tests (DNS, outbound, identity) before marking the VM as ready\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{id:\"step-3-continuous-validation\",children:(0,t.jsx)(e.a,{href:\"#step-3-continuous-validation\",children:\"Step 3: Continuous validation\"})}),`\n`,(0,t.jsx)(e.p,{children:\"A nightly job rehydrates sample VMs from each template, runs compliance scans, and feeds the results into Grafana dashboards. If drift appears, we can flag the template, notify owners, and block new labs until it\\u2019s healthy.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"step-4-retirement-workflow\",children:(0,t.jsx)(e.a,{href:\"#step-4-retirement-workflow\",children:\"Step 4: Retirement workflow\"})}),`\n`,(0,t.jsx)(e.p,{children:\"When a template ages out, we snapshot it, store the artifacts in object storage, and document the replacement in the knowledge base. Faculty see the impact in the portal release notes, keeping everyone aligned.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Templates went from \\u201Cmystery meat\\u201D to a predictable, observable backbone for CyberRange labs.\"})]})}function v(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var j=v;return y(x);})();\n;return Component;"
    },
    "_id": "blog/vcenter-templates.mdx",
    "_raw": {
      "sourceFilePath": "blog/vcenter-templates.mdx",
      "sourceFileName": "vcenter-templates.mdx",
      "sourceFileDir": "blog",
      "contentType": "mdx",
      "flattenedPath": "blog/vcenter-templates"
    },
    "type": "Post",
    "slug": "vcenter-templates",
    "url": "/blog/vcenter-templates"
  }
]